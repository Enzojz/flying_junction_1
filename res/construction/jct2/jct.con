local func = require "jct/func"
local pipe = require "jct/pipe"
local coor = require "jct/coor"
local line = require "jct/coorline"
local arc = require "jct/coorarc"
local quat = require "jct/quaternion"
local jct = require "jct2"
local dump = require "luadump"

local table = table
local insert = table.insert
local math = math
local pi = math.pi

local rList = {15, 12, 10, 8, 7.5, 6, 5, 4, 3.5, 3, 2.5, 2, 1.75, 1.5, 1.25, 1, 0.9, 0.85, 0.8, 0.75, 0.7, 0.666, 0.633, 0.6, 0.566, 0.533, 0.5, 0.475, 0.45, 0.425, 0.4, 0.375, 0.35, 0.325, 0.3, 0.28, 0.26, 0.24, 0.22, 0.2, 0.18, 0.16, 0.14, 0.12, 0.1, 0.09, 0.08, 0.07, 0.06, 0.05}

rList = pipe.new * rList * pipe.map(pipe.neg()) * pipe.rev() / jct.infi + rList
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}

local infi = 1e8

local tunnelHeightList = {6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11, 11.5, 12}
local rList = pipe.new
    * func.seqMap({1, 100}, function(n)
        local p = n * 0.01
        return -(p * p * p * p * p) * 9900 - 100
    end)
    * function(rs) return rs + {infi} + rs * pipe.map(pipe.neg()) * pipe.rev() end

local xDeg = pipe.new
    * func.seqMap({5, 180}, function(d) return d * 0.5 end)
    * function(rs) return rs * pipe.map(pipe.neg()) * pipe.rev() + rs end

local fitModels = {
    wall = jct.fitModel(0.5, 5, -1, true, true),
    fence = jct.fitModel(0.5, 5, -1, true, true),
    surface = jct.fitModel(5, 5, -1, true, true),
    front = jct.fitModel(5, 0.5, -1, true, true)
}

---@param modules modules
---@return classified_modules
local function classifyModules(modules)
    local result = {}
    for slotId, m in pairs(modules) do
        if (m.metadata and m.metadata.preClassify) then
            game.res.script[m.metadata.scriptName][m.metadata.preClassify](modules, result, slotId)
        end
    end
    for slotId, m in pairs(modules) do
        if (m.metadata and m.metadata.classify) then
            game.res.script[m.metadata.scriptName][m.metadata.classify](modules, result, slotId)
        end
    end
    return result
end

local constructionTemplates = {
    {
        constructionType = "TRACK_CONSTRUCTION",
        type = "DYNAMIC",
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        description = {
            name = _("MENU_NAME"),
            description = _("MENU_DESC"),
        -- icon = "ui/jct/jct.tga"
        },
        data = {
            params = {
                {
                    key = "trackNbLower",
                    name = _("MENU_TRACK_NR_LOWER"),
                    values = func.map(trackNumberList, tostring),
                    uiType = "SLIDER",
                    defaultIndex = 1
                },
                {
                    key = "trackNbUpper",
                    name = _("MENU_TRACK_NR_UPPER"),
                    values = func.map(trackNumberList, tostring),
                    uiType = "SLIDER",
                    defaultIndex = 1
                },
                {
                    key = "trackType",
                    name = _("MENU_TRACK_TYPE"),
                    uiType = "COMBOBOX",
                    values = {_("Standard"), _("High-Speed")},
                    defaultIndex = 0
                },
                {
                    key = "catenary",
                    name = _("MENU_TRACK_CAT"),
                    uiType = "CHECKBOX",
                    values = {"0", "1"},
                    defaultIndex = 0
                },
                {
                    key = "xDeg",
                    name = _("MENU_X_DEG"),
                    values = func.map(xDeg, tostring),
                    uiType = "SLIDER",
                    defaultIndex = 270
                },
                {
                    key = "rUpper",
                    name = _("MENU_R_UPPER"),
                    values = func.map(rList, tostring),
                    uiType = "SLIDER",
                    defaultIndex = (#rList - 1) / 2
                },
                {
                    key = "rLower",
                    name = _("MENU_R_LOWER"),
                    values = func.map(rList, tostring),
                    uiType = "SLIDER",
                    defaultIndex = (#rList - 1) / 2
                },
                {
                    key = "tunnelHeight",
                    name = _("MENU_TUNNEL_HEIGHT"),
                    values = func.map(tunnelHeightList, tostring),
                    uiType = "SLIDER",
                    defaultIndex = 4
                },
                {
                    key = "wallType",
                    name = _("MENU_WALL_STYLE"),
                    values = {
                        "ui/jct/concrete.tga",
                        "ui/jct/brick.tga",
                        "ui/jct/brick_2.tga"
                    },
                    uiType = "ICON_BUTTON",
                    defaultIndex = 0
                },
                {
                    key = "extType",
                    name = _("EXT_TYPE"),
                    values = {_("ZIGZAG"), _("ALIGNED")},
                    defaultIndex = 0
                },
            }
        },
    }
}

---@param params params
---@return table
local createTemplateFn = function(params)
    local result = {}
    
    local id = 1
    do
        local z = 0
        for _, x in ipairs(func.seq(0, params.trackNbLower)) do
            for _, y in ipairs({1, -1}) do
                result[jct.base(id, 1)] = "jct2/tracks/standard.module"
                
                local info = {
                    id = id,
                    type = 1,
                    pos = coor.xyz(x, y, z),
                    length = 20,
                    width = 5,
                    ref = {},
                    straight = true
                }
                
                
                local slotId, slotIds = jct.slotIds(info)
                for m, slotIds in pairs(slotIds) do
                    for _, slotId in ipairs(slotIds) do
                        result[slotId] = string.format("jct2/data/%s.module", m)
                    end
                end
                id = id + 1
            end
        end
    end
    
    do
        local z = 1
        for _, x in ipairs(func.seq(0, params.trackNbUpper)) do
            for _, y in ipairs({1, -1}) do
                result[jct.base(id, 1)] = "jct2/tracks/standard.module"
                
                local info = {
                    id = id,
                    type = 1,
                    pos = coor.xyz(x, y, z),
                    length = 20,
                    width = 5,
                    ref = {},
                    straight = true
                }
                
                local slotId, slotIds = jct.slotIds(info)
                for m, slotIds in pairs(slotIds) do
                    for _, slotId in ipairs(slotIds) do
                        result[slotId] = string.format("jct2/data/%s.module", m)
                    end
                end
                id = id + 1
            end
        end
        
        for _, x in ipairs({-1, params.trackNbUpper + 1}) do
            for _, y in ipairs({1, -1}) do
                result[jct.base(id, 1)] = "jct2/wall.module"
                
                local info = {
                    id = id,
                    type = 3,
                    pos = coor.xyz(x, y, z),
                    length = 20,
                    width = 0.5,
                    ref = {},
                    straight = true
                }
                
                local slotId, slotIds = jct.slotIds(info)
                for m, slotIds in pairs(slotIds) do
                    for _, slotId in ipairs(slotIds) do
                        result[slotId] = string.format("jct2/data/%s.module", m)
                    end
                end
                id = id + 1
            end
        end
    end
    
    return result
end

---@param modules modules
---@return modules
local preProcessFn = function(modules, change)
    local classedModules = classifyModules(modules)
    
    local type, id, data = jct.slotInfo(change.slotId)
    
    local info = {
        type = type,
        id = id,
        data = data
    }
    
    if change.added then
        if change.module.metadata.preProcessAdd then
            game.res.script[change.module.metadata.scriptName][change.module.metadata.preProcessAdd](modules, change, classedModules, info)
        else
            if data == -1 then
                modules[change.slotId] = nil
                modules[jct.base(id, change.module.metadata.typeId)] = change.module
            else
                modules[change.slotId] = nil
                modules[jct.mixData(jct.base(id, change.module.metadata.typeId), data)] = change.module
            end
        end
        
        for k, module in pairs(modules) do
            if (module.metadata and module.metadata.preProcessPostAdd) then
                game.res.script[module.metadata.scriptName][module.metadata.preProcessPostAdd](modules, change, k, classedModules, info)
            end
        end
    else
        local m = modules[change.slotId]
        if m.metadata.preProcessRemove then
            game.res.script[m.metadata.scriptName][m.metadata.preProcessRemove](modules, change, classedModules, info)
        else
            modules[change.slotId] = nil
        end
    end
    
    return modules
end

local upgradeFn = function(params)
    local classedModules = classifyModules(params.modules)
    jct.octa(params.modules, classedModules)
    local result = {}
    local lut = {}
    local function searchTracks(slotId)
        lut[slotId] = true
        local m = params.modules[slotId]
        local info = m.info
        for _, octa in ipairs({info.octa[1], info.octa[5]}) do
            if octa and params.modules[octa] and params.modules[octa].metadata.isTrack then
                if not lut[octa] then
                    searchTracks(octa)
                end
            end
        end
    end
    searchTracks(params.slotId)
    
    if params.catenaryToggle == 1 then
        for slotId, _ in pairs(lut) do
            local module = params.modules[slotId]
            insert(result, {module.makeData(27, 0), "jct2/catenary.module"})
        end
    end
    
    if params.trackTypeToggle == 1 then
        for slotId, _ in pairs(lut) do
            local module = params.modules[slotId]
            insert(result, {slotId, ("jct2/tracks/%s.module"):format(module.name:match("high_speed") and "standard" or "high_speed")})
        end
    end
    
    return result
end


---@param modules modules
---@param classedModules classified_modules
---@return grid
local octa = function(modules, classedModules)
    local grid = {}
    
    -- 8 1 2
    -- 7 x 3
    -- 6 5 4
    for id, info in pairs(classedModules) do
        local pos = modules[info.slotId].info.pos
        local x, y, z = pos.x, pos.y, pos.z
        if not grid[z] then grid[z] = {} end
        if not grid[z][y] then grid[z][y] = {} end
        grid[z][y][x] = info.slotId
    end
    
    for slotId, module in pairs(modules) do
        if module.metadata.isTrack or module.metadata.isStreet or module.metadata.isWall or module.metadata.isPlaceholder then
            local info = module.info
            local x, y, z = info.pos.x, info.pos.y, info.pos.z
            
            if grid[z][y][x - 1] then
                modules[grid[z][y][x - 1]].info.octa[3] = slotId
                module.info.octa[7] = grid[z][y][x - 1]
            end
            
            if grid[z][y][x + 1] then
                modules[grid[z][y][x + 1]].info.octa[7] = slotId
                module.info.octa[3] = grid[z][y][x + 1]
            end
            
            if grid[z][y - 1] and grid[z][y - 1][x] then
                modules[grid[z][y - 1][x]].info.octa[1] = slotId
                module.info.octa[5] = grid[z][y - 1][x]
            end
            
            if grid[z][y - 1] and grid[z][y - 1][x - 1] then
                modules[grid[z][y - 1][x - 1]].info.octa[2] = slotId
                module.info.octa[6] = grid[z][y - 1][x - 1]
            end
            
            if grid[z][y - 1] and grid[z][y - 1][x + 1] then
                modules[grid[z][y - 1][x + 1]].info.octa[8] = slotId
                module.info.octa[4] = grid[z][y - 1][x + 1]
            end
            
            if grid[z][y + 1] and grid[z][y + 1][x] then
                modules[grid[z][y + 1][x]].info.octa[5] = slotId
                module.info.octa[1] = grid[z][y + 1][x]
            end
            
            if grid[z][y + 1] and grid[z][y + 1][x - 1] then
                modules[grid[z][y + 1][x - 1]].info.octa[4] = slotId
                module.info.octa[8] = grid[z][y + 1][x - 1]
            end
            
            if grid[z][y + 1] and grid[z][y + 1][x + 1] then
                modules[grid[z][y + 1][x + 1]].info.octa[6] = slotId
                module.info.octa[2] = grid[z][y + 1][x + 1]
            end
        end
    end
    return grid
end

---@param modules modules
---@param classedModules classified_modules
---@return table
---@return integer
local gridization = function(modules, classedModules)
    local grid = octa(modules, classedModules)
    local queue = pipe.new * {}
    local cr = {}
    
    for z, g in pairs(grid) do
        local ySeq = func.sort(func.keys(g))
        for _, y in ipairs(ySeq) do
            if y >= 0 then
                local xSeq = func.sort(func.keys(g[y]))
                
                for _, x in ipairs(xSeq) do
                    if x >= 0 then
                        insert(queue, g[y][x])
                    end
                end
                for _, x in ipairs(func.rev(xSeq)) do
                    if x < 0 then
                        insert(queue, g[y][x])
                    end
                end
            end
        end
        
        for _, y in ipairs(func.rev(ySeq)) do
            if y < 0 then
                local xSeq = func.sort(func.keys(g[y]))
                
                for _, x in ipairs(xSeq) do
                    if x >= 0 then
                        insert(queue, g[y][x])
                    end
                end
                for _, x in ipairs(func.rev(xSeq)) do
                    if x < 0 then
                        insert(queue, g[y][x])
                    end
                end
            end
        end
    
    end
    
    -- Collect X postion and width information
    -- Process in Y axis
    local processY = function(fn, pos)
        return function()
            local data = {
                modules = modules,
                grid = grid,
            }
            
            fn(pos, data)
        end
    end
    
    for _, slotId in ipairs(queue) do
        dump()(modules[slotId].info.pos)
        local m = modules[slotId]
        if (m.metadata.scriptName and game.res.script[m.metadata.scriptName]) then
            local fn = game.res.script[m.metadata.scriptName][m.metadata.gridization]
            if fn then
                local pos = modules[slotId].info.pos
                cr[slotId] = coroutine.create(processY(fn, pos))
            end
        end
    end
    
    for _, slotId in ipairs(queue) do
        local result = coroutine.resume(cr[slotId])
        if not result then
            error(debug.traceback(cr[slotId]))
        end
    end
    
    for _, slotId in ipairs(queue) do
        local result = coroutine.resume(cr[slotId])
        if not result then
            error(debug.traceback(cr[slotId]))
        end
    end
    for _, slotId in ipairs(queue) do
        local result = coroutine.resume(cr[slotId])
        if not result then
            error(debug.traceback(cr[slotId]))
        end
    end
    
    return grid
end

---@alias vec3 {[1]: number, [2]:number, [3]: number}
---@alias vec2 {[1]: number, [2]:number}
---
---@class terrain_alignment
---@field type "EQUAL"|"LESS"|"GREATER"
---@field faces vec3[][]
---
---@class ground_face
---@field mode {type: "FILL"|"STROKE"|"STROKE_OUTER"|"STROKE_INNER", key: string}
---@field face vec3[]
---
---@class collider
---@field params {halfExtents: vec3}|{points: vec3[]}
---@field transf matrix
---@field type "BOX"|"CYLINDER"|"POINT_CLOUD"
---
---@class terminal_group
---@field terminals {[1]: integer, [2]: integer}[]
---@field vehicleNodeOverride integer
---
---@class station
---@field terminals integer[]
---@field tag string
---
---@class edge_list
---@field type "STREET"|"TRACK"
---@field params {type: string, tramTrackType?: "YES"|"NO", catenary: boolean}
---@field edgeType? "BRIDGE"|"TUNNEL"
---@field edgeTypeName? string
---@field edges {[1]: vec3, [2]: vec3}[]
---@field snapNodes integer[]
---@field freeNodes? integer[]
---@field tag2Nodes table<string, integer[]>
---
---@class slotConfig
---@field maxModules integer
---@field message string
---@field skipCollisionCheck boolean
---
---@class model
---@field id string
---@field transf matrix
---@field tag string
---
---@class slot
---@field id integer
---@field type string
---@field transf matrix
---@field spacing {[1]: number, [2]: number, [3]: number, [4]: number}
---@field shape integer
---@field height number
---
---@class param
---@field key string
---@field name? string
---@field uiType? "BUTTON"|"SLIDER"|"COMBOBOX"|"ICON_BUTTON"|"CHECKBOX"
---@field values string[]
---@field defaultIndex? integer
---@field yearFrom? integer
---@field yearTo integer
---@field tooltip string
---
---@class params
---@field modules modules
---@field classedModules classified_modules
---
---@class result
---@field entryConnectors table
---@field colliders collider[]
---@field terminalGroups terminal_group[]
---@field groundFaces ground_face[]
---@field terrainAlignmentLists terrain_alignment[]
---@field stations station[]
---@field edgeLists edge_list[]
---@field slotConfig table<string, slotConfig>
---@field models model[]
---@field slots slot[]
---@field labelText? table<integer, string[]>
---@field cost? integer
---@field bulldozeCost? integer
---@field maintenanceCost? integer
---@field connectors any
---@field connections any
---@field invokeLater fun()[]
---
---comment
---@param params params
---@param closureParams any
---@return result
local updateFn = function(params, closureParams)
        ---@type result
        local result = {
            colliders = {},
            terrainAlignmentLists = {
                {type = "EQUAL", faces = {}},
                {type = "LESS", faces = {}},
                {type = "GREATER", faces = {}},
                {type = "EQUAL", faces = {}, optional = true},
                {type = "LESS", faces = {}, optional = true},
                {type = "GREATER", faces = {}, optional = true}
            },
            terrainLists = {},
            groundFaceLists = {},
            groundFaces = {},
            edgeLists = {},
            slotConfig = {
                jct_street = {
                    skipCollisionCheck = true,
                },
                jct_remove = {
                    skipCollisionCheck = true,
                }
            },
            cost = 0,
            models = pipe.new * {},
            slots = {},
            dependentSlots = {},
            
            labelText = {},
            invokeLater = {}
        }
        
        local xDeg = xDeg[params.xDeg + 1]
        local xRad = xDeg / 180 * pi
        
        params.xRad = xRad
        params.tunnelHeight = tunnelHeightList[params.tunnelHeight + 1] or 8
        params.classedModules = classifyModules(params.modules)
        
        for slotId, m in pairs(params.modules) do
            if (m.metadata and m.metadata.postClassify) then
                game.res.script[m.metadata.scriptName][m.metadata.postClassify](params.modules, result, slotId, params)
            end
        end
        
        params.grid = gridization(params.modules, params.classedModules)
        
        params.edgeIndex = {}
        params.slotGrid = {}
        
        -- slotSetup adds slots for modules itself
        for slotId, module in pairs(params.modules) do
            if module.metadata.slotSetup then
                game.res.script[module.metadata.scriptName][module.metadata.slotSetup](params, result, slotId)
            end
        end
        
        -- addSlot adds slots for
        for k, s in pairs(game.res.script) do
            if s.addSlot and k:match("construction/jct2/") then
                s.addSlot(params, result)
            end
        end
        
        result.terminateConstructionHook = function()
            for _, z in pairs(params.slotGrid) do
                for _, x in pairs(z) do
                    for _, y in pairs(x) do
                        for _, s in pairs(y) do
                            insert(result.slots, s)
                        end
                    end
                end
            end
            
            for _, fn in ipairs(result.invokeLater) do
                fn()
            end
            
            for id, terrains in pairs(result.terrainLists) do
                if terrains.equal then
                    for _, t in ipairs(terrains.equal) do
                        insert(result.terrainAlignmentLists[1].faces, t)
                    end
                end
                if terrains.less then
                    for _, t in ipairs(terrains.less) do
                        insert(result.terrainAlignmentLists[2].faces, t)
                    end
                end
                if terrains.greater then
                    for _, t in ipairs(terrains.greater) do
                        insert(result.terrainAlignmentLists[3].faces, t)
                    end
                end
                if terrains.equalOpt then
                    for _, t in ipairs(terrains.equalOpt) do
                        insert(result.terrainAlignmentLists[4].faces, t)
                    end
                end
                if terrains.lessOpt then
                    for _, t in ipairs(terrains.lessOpt) do
                        insert(result.terrainAlignmentLists[5].faces, t)
                    end
                end
                if terrains.greaterOpt then
                    for _, t in ipairs(terrains.greaterOpt) do
                        insert(result.terrainAlignmentLists[6].faces, t)
                    end
                end
            end
            
            for id, groundFace in pairs(result.groundFaceLists) do
                insert(result.groundFaces, groundFace)
            end
        end
        return result
end

function data()
    return {
        type = "TRACK_CONSTRUCTION",
        description = {
            name = _("FLYING_JUNCTION"),
            description = ""
        },
        categories = {"track_construction"},
        availability = {
            yearFrom = 0,
            yearTo = 0,
        },
        order = 1000,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        params = {
            {
                key = "debug",
                name = _("MENU_DEBUG"),
                values = {_("No"), _("Yes")},
                defaultIndex = 0
            },
        },
        upgradeFn = upgradeFn,
        updateFn = updateFn,
        preProcessFn = preProcessFn
    }
end
