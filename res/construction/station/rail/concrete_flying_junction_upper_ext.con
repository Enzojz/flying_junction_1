local paramsutil = require "paramsutil"
local func = require "flyingjunction/func"
local coor = require "flyingjunction/coor"
local trackEdge = require "flyingjunction/trackedge"
local line = require "flyingjunction/coorline"
local arc = require "flyingjunction/coorarc"
local station = require "flyingjunction/stationlib"
local pipe = require "flyingjunction/pipe"
local junction = require "junction"

local dump = require "datadumper"

local mSidePillar = "station/concrete_flying_junction/infra_junc_pillar_side.mdl"
local mRoofFenceF = "station/concrete_flying_junction/infra_junc_roof_fence_front.mdl"
local mRoofFenceS = "station/concrete_flying_junction/infra_junc_roof_fence_side.mdl"
local mRoof = "station/concrete_flying_junction/infra_junc_roof.mdl"
local bridgeType = "z_concrete_flying_junction.lua"

local rList = {1e5, 5, 3, 2, 1.5, 1, 0.75, 0.5, 2 / 3, 0.4, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 7, 1 / 8, 1 / 9, 0.1}
local slopeList = {15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70}
local heightList = {11, 10, 9, 8, 7, 6, 5, 4, 3}
local wallHeight = 11

local function params()
    return {
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6"), },
            defaultIndex = 1
        },
        {
            key = "radius",
            name = _("Radius") .. ("(m)"),
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "isMir",
            name = _("Mirrored"),
            values = {_("No"), _("Yes")},
            defaultIndex = 0
        },
        {
            key = "slope",
            name = _("Slope(‰)"),
            values = func.map(slopeList, tostring),
            defaultIndex = 3
        },
        {
            key = "dz",
            name = _("ΔHeight") .. ("(m)"),
            values = func.map(heightList, tostring),
            defaultIndex = 3
        }
    }

end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    
    func.forEach(params(), function(i) param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Concrete Flying Junction"),
            description = _("An European style flying junction")
        },
        availability = {
            yearFrom = 1892
        },
        order = 27218,
        params = params(),
        
        updateFn = function(params)
            defaultParams(params)
            
            local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
            local catenary = params.catenary == 1
            local trackBuilder = trackEdge.builder(catenary, trackType)
            local height = heightList[params.dz + 1]
            
            local nbTracks = params.nbTracks + 1
            local r = rList[params.radius + 1] * 1000
            
            local slope = pipe.exec
                * function()
                    local slope = slopeList[params.slope + 1] * 0.001
                    local rad = math.atan(slope)
                    local rTrans = 300
                    local trans = {
                        r = rTrans,
                        dz = rTrans * (1 - math.cos(rad)),
                        length = rTrans * math.sin(rad)
                    }
                    return {
                        slope = slope,
                        rad = rad,
                        length = (height - 2 * trans.dz) / slope + 2 * trans.length,
                        trans = trans
                    }
                end
            
            local rad = slope.length / r
            local radT = slope.trans.length / slope.length * rad
            
            local slopeProfile = pipe.exec
                * function()
                    local arc1 = arc.new(0, -slope.trans.r, slope.trans.r + height)
                    local arc2 = arc.new(slope.length, slope.trans.r, slope.trans.r)
                    return {
                        {
                            arc = arc1,
                            inf = arc1:pt(math.pi * 0.5),
                            sup = arc1:pt(math.pi * 0.5 - slope.rad)
                        },
                        {
                            arc = arc.byOR(arc.byDR(arc1, 1e5):pt(math.pi * 0.5 - slope.rad), 1e5),
                            inf = arc1:pt(math.pi * 0.5 - slope.rad),
                            sup = coor.xy(slope.length * 0.5, height * 0.5)
                        },
                        {
                            arc = arc.byOR(arc.byDR(arc2, 1e5):pt(-math.pi * 0.5 - slope.rad), 1e5),
                            inf = coor.xy(slope.length * 0.5, height * 0.5),
                            sup = arc2:pt(-math.pi * 0.5 - slope.rad),
                        },
                        {
                            arc = arc2,
                            inf = arc2:pt(-math.pi * 0.5 - slope.rad),
                            sup = arc2:pt(-math.pi * 0.5)
                        }
                    }
                end
            
            local radRef = (r > 0 and math.pi or 0)
            
            local function retriveZ(rx)
                local x = (rx - radRef) / rad * slope.length
                local pf = func.filter(slopeProfile, function(s) return (s.inf.x <= x and s.sup.x >= x) or (math.abs(s.inf.x - x) < 1e-5) or (math.abs(s.sup.x - x) < 1e-5) end)[1]
                return func.min(pf.arc / line.byVecPt(coor.xy(0, 1), coor.xy(x, 0)), function(p, q) return (p - (pf.inf + pf.sup) * 0.5):length() < (q - (pf.inf + pf.sup) * 0.5):length() end)
            end
            
            local function mPlace(guideline, rad1, rad2)
                local radc = (rad1 + rad2) * 0.5
                local p1, p2 = retriveZ(rad1), retriveZ(rad2)
                return coor.shearZoY((p2.y - p1.y) / (p2.x - p1.x)) * coor.rotZ(radc) * coor.trans(func.with(guideline:pt(radc), {z = ((p1 + p2) * 0.5).y - wallHeight}))
            end
            
            local offsets = junction.buildCoors(nbTracks, nbTracks)
            local generateGroup = function(o) return pipe.new
                * junction.fArcs(o, 0, r)
                * pipe.map(function(t) return
                    {
                        {
                            limits = {
                                inf = radRef + rad,
                                mid = radRef + rad - radT,
                                sup = radRef + 0.5 * rad,
                            },
                            guideline = t,
                        },
                        {
                            limits = {
                                inf = radRef + 0.5 * rad,
                                mid = radRef + radT,
                                sup = radRef,
                            },
                            guideline = t,
                        }
                    } end)
            end
            
            local groups = {
                tracks = generateGroup(offsets.tracks),
                walls = generateGroup(offsets.walls)
            }
            
            local makeStructure = function(group, fMake)
                return group
                    * pipe.map(pipe.map(fMake))
                    * pipe.flatten()
                    * pipe.flatten()
                    * pipe.flatten()
            end
            local walls =
                makeStructure(groups.walls, junction.makeFn(mSidePillar, mPlace, coor.scaleY(1.05)))
                + makeStructure(groups.walls, junction.makeFn(mRoofFenceS, mPlace, coor.scaleY(1.05)))
                + makeStructure(groups.tracks, junction.makeFn(mRoof, mPlace, coor.scaleY(1.05)))
            
            local edges = pipe.new
                * func.map(groups.tracks, pipe.map(junction.generateArc))
                * pipe.map(function(ar) return {ar[1][3], ar[1][1], ar[1][2], ar[2][1], ar[2][2], ar[2][4]} end)
                * pipe.map(function(ar) return pipe.new
                    * {0, 0, slope.trans.dz, 5.5, height - slope.trans.dz, height, height}
                    * pipe.zip({0, 0, slope.slope, slope.slope, slope.slope, 0, 0}, {"z", "s"})
                    * function(lz) return
                        lz * pipe.range(1, #lz - 1)
                        * pipe.map2(lz * pipe.range(2, #lz), function(a, b) return func.map({a.z, b.z, a.s, b.s}, coor.transZ) end)
                    end
                    * pipe.map2(ar, function(nz, ar) return func.map2(ar, nz, coor.apply) end)
                end)
                * pipe.map(pipe.map(pipe.map(coor.vec2Tuple)))
                * pipe.map(pipe.zip({{true, false}, {false, false}, {false, false}, {false, false}, {false, false}, {false, true}}, {"edge", "snap"}))
                * pipe.flatten()
                * station.prepareEdges
                * trackBuilder.nonAligned()
            
            local polys = junction.generatePolyArcEdge(groups.walls[2][1].guideline, groups.walls[2][1].limits.inf, groups.walls[2][2].limits.sup)
                + junction.generatePolyArcEdge(groups.walls[1][1].guideline, groups.walls[1][2].limits.sup, groups.walls[1][1].limits.inf)
            
            local polyTracks = polys * pipe.map(function(c) return coor.transZ(retriveZ(c.rad).y)(c) end)
            
            local result =
                {
                    edgeLists = {edges},
                    models = walls,
                    terrainAlignmentLists = {
                        {
                            type = "GREATER",
                            faces = {polys * pipe.map(coor.vec2Tuple)}
                        },
                        {
                            type = "LESS",
                            faces = {polyTracks * pipe.map(coor.vec2Tuple)}
                        }
                    }
                }
            
            
            -- End of generation
            -- Slope, Height, Mirror treatment
            local mirrored = params.isMir == 1
            local mf = mirrored and coor.flipX() or coor.I()
            local mpt, mvec = mf, mf
            
            local mapEdgeList = function(edgeList)
                return func.with(edgeList, {edges = func.map(edgeList.edges, coor.applyEdge(mpt, mvec))})
            end
            
            local mapModel = function(model) return func.with(model, {transf = model.transf * mpt}) end
            
            local mapTerrainList = function(ta)
                local mapTerrain = function(t) return (coor.tuple2Vec(t) .. mpt):toTuple() end
                local mapFaces = function(faces) return (mirrored and func.rev or func.nop)(func.map(faces, mapTerrain)) end
                return func.with(ta, {faces = func.map(ta.faces, mapFaces)})
            end
            
            return func.with(result,
                {
                    edgeLists = func.map(result.edgeLists, mapEdgeList),
                    models = func.map(result.models, mapModel),
                    terrainAlignmentLists = func.map(result.terrainAlignmentLists, mapTerrainList),
                    groundFaces = {},
                    terminalGroups = {},
                    cost = 1000,
                    maintenanceCost = 1000 / 6
                })
        end
    }

end
