local laneutil = require "laneutil"
local paramsutil = require "paramsutil"
local func = require "func"
local coor = require "coor"
local trackEdge = require "trackedge"
local line = require "coorline"
local arc = require "coorarc"
local station = require "stationlib"

local mSidePillar = "station/concrete_flying_junction/infra_junc_pillar_side.mdl"
local mRoofFenceF = "station/concrete_flying_junction/infra_junc_roof_fence_front.mdl"
local mRoofFenceS = "station/concrete_flying_junction/infra_junc_roof_fence_side.mdl"
local mRoof = "station/concrete_flying_junction/infra_junc_roof.mdl"
local bridgeType = "z_concrete_flying_junction.lua"

local listDegree = {5, 10, 20, 30, 40, 50, 60, 70, 80}
local rList = {-0.1, -0.3, -0.5, -1, 1e5, 1, 0.5, 0.3, 0.1}
local rTxtList = {"●", "●", "•", "∙", "0", "∙", "•", "●", "●"}

local slopeList = {0, 10, 20, 25, 30, 35, 40, 50, 60}
local heightList = {-5, -2.5, -0.5, 0, 0.5, 2.5, 5}

local snapRule = function(e) return func.filter(func.seq(0, #e - 1), function(e) return e % 4 == 0 or (e - 3) % 4 == 0 end) end

local newModel = function(m, ...)
    return {
        id = m,
        transf = coor.mul(...)
    }
end

function buildCoors(numTracks, groupSize)
    local function builder(xOffsets, uOffsets, baseX, nbTracks)
        local function caller(n)
            return builder(
                func.concat(xOffsets, func.seqMap({1, n}, function(n) return baseX - 0.5 * station.trackWidth + n * station.trackWidth end)),
                func.concat(uOffsets, {baseX + n * station.trackWidth + 0.25}),
                baseX + n * station.trackWidth + 0.5,
                nbTracks - n)
        end
        if (nbTracks == 0) then
            local offset = function(o) return o - baseX * 0.5 end
            return {tracks = func.map(xOffsets, offset), walls = func.map(uOffsets, offset)}
        elseif (nbTracks < groupSize) then
            return caller(nbTracks)
        else
            return caller(groupSize)
        end
    end
    return builder({}, {0.25}, 0.5, numTracks)
end

local function normalizeRad(rad)
    return (rad > math.pi * -0.5) and rad or normalizeRad(rad + math.pi * 2)
end

local generateArc = function(arc)
    local toXyz = function(pt) return coor.xyz(pt.x, pt.y, 0) end
    
    local radSup = normalizeRad(arc.limits.sup)
    local radMid = normalizeRad(arc.limits.mid)
    local radInf = normalizeRad(arc.limits.inf)
    
    local sup = toXyz(arc.guideline:pt(radSup))
    local inf = toXyz(arc.guideline:pt(radInf))
    local mid = toXyz(arc.guideline:pt(radMid))
    
    local toVector = function(rad) return coor.xyz(0, (arc.limits.mid > math.pi * 0.5 or arc.limits.mid < -math.pi * 0.5) and -1 or 1, 0) .. coor.rotZ(rad) end
    
    local vecSup = toVector(radSup)
    local vecInf = toVector(radInf)
    local vecMid = toVector(radMid)
    
    local supExt = sup + vecSup
    local infExt = inf - vecInf
    
    return {
        {inf, mid, vecInf, vecMid},
        {mid, sup, vecMid, vecSup},
        {infExt, inf, vecInf, vecInf},
        {sup, supExt, vecSup, vecSup},
    }
end

local function average(op1, op2) return (op1 + op2) * 0.5, (op1 + op2) * 0.5 end

local generateTrackGroups = function(tracks1, tracks2, trans)
    trans = trans or {mpt = coor.I(), mvec = coor.I()}
    return {
        normal = func.flatten(func.map2(tracks1, tracks2,
            function(t1, t2)
                local seg = {generateArc(t1)[1], generateArc(t2)[2]}
                seg[1][2], seg[2][1] = average(seg[1][2], seg[2][1])
                seg[1][4], seg[2][3] = average(seg[1][4], seg[2][3])
                return
                    func.p * seg * func.bind(func.map, nil, function(s) return func.map(s, coor.vec2Tuple) end) * laneutil.makeLanes * coor.applyEdges(trans.mpt, trans.mvec) / 0
            end)
        ),
        ext = func.flatten(func.map2(tracks1, tracks2,
            function(t1, t2)
                local seg = {generateArc(t1)[3], generateArc(t2)[4]}
                return
                    func.p * seg * func.bind(func.map, nil, function(s) return func.map(s, coor.vec2Tuple) end) * laneutil.makeLanes * coor.applyEdges(trans.mpt, trans.mvec) / 0
            end)
    ),
    }
end

local fArcs = function(offsets, rad, r)
    return func.map(offsets, function(x)
        return arc.byOR(
            coor.xyz(r, 0, 0) .. coor.rotZ(rad),
            math.abs(r - x)
    ) end
)
end

local ptXSelector = function(lhs, rhs) return lhs:length() < rhs:length() end

local minimalR = function(offsets, info)
    local offsetLower = {offsets.lower.walls[1], offsets.lower.walls[#offsets.lower.walls]}
    local offsetUpper = {offsets.upper.walls[1], offsets.upper.walls[#offsets.upper.walls]}
    
    local function incr(r)
        return r == 0 and 0 or (r > 0 and r + 1 or r - 1)
    end
    
    local function calculate(rLower, rUpper)
        
        local lowerGuideline = fArcs(offsetLower, info.lower.rad, rLower)
        local upperGuideline = fArcs(offsetUpper, info.upper.rad, rUpper)
        
        local resultTest = (
            #(lowerGuideline[1] - upperGuideline[1]) > 1 and
            #(lowerGuideline[1] - upperGuideline[2]) > 1 and
            #(lowerGuideline[2] - upperGuideline[1]) > 1 and
            #(lowerGuideline[2] - upperGuideline[2]) > 1
        )
        if (resultTest) then
            return rLower, rUpper
        else
            return calculate(incr(rLower), rLower == rUpper and rUpper or incr(rUpper))-- if else to prevent infinit loop
        end
    end
    return calculate(info.lower.r, info.upper.r)
end

local function attach(limits)
    return function(l, x)
        return {
            limits = limits,
            xOffset = x,
            guideline = l,
        }
    end
end

local function part(rad)
    return function(info, offsets)
        info.lower.r, info.upper.r = minimalR(offsets, info)
        
        local guidelines =
            {
                lower = {
                    tracks = fArcs(offsets.lower.tracks, info.lower.rad, info.lower.r),
                    walls = fArcs(offsets.lower.walls, info.lower.rad, info.lower.r),
                    level = line.byRadPt(info.lower.rad, coor.o)
                },
                upper = {
                    tracks = fArcs(offsets.upper.tracks, info.upper.rad, info.upper.r),
                    walls = fArcs(offsets.upper.walls, info.upper.rad, info.upper.r),
                    level = line.byRadPt(info.upper.rad, coor.o)
                }
            }
        
        local limits = {
            lower = {L = guidelines.lower.walls[1], R = guidelines.lower.walls[#guidelines.lower.walls]},
            upper = {L = guidelines.upper.walls[1], R = guidelines.upper.walls[#guidelines.upper.walls]}
        }
        
        local limitRads = {
            lower = {
                inf = limits.lower.R:rad(func.min(limits.lower.R - limits.upper.L, ptXSelector)),
                mid = limits.lower.R:rad(coor.xy(0, 0)),
                sup = limits.lower.L:rad(func.min(limits.lower.L - limits.upper.R, ptXSelector)),
            },
            upper = {
                sup = limits.upper.R:rad(func.min(limits.upper.R - limits.lower.L, ptXSelector)),
                mid = limits.upper.R:rad(coor.xy(0, 0)),
                inf = limits.upper.L:rad(func.min(limits.upper.L - limits.lower.R, ptXSelector)),
            }
        }
        
        return {
            lower = {
                tracks = func.map2(guidelines.lower.tracks, offsets.lower.tracks,
                    attach(limitRads.lower)),
                walls = func.p
                * func.map2(guidelines.lower.walls, offsets.lower.walls, function(l, o)
                    return attach(
                        {
                            inf = l:rad(func.min(l - limits.upper.L, ptXSelector)),
                            mid = l:rad(coor.xy(0, 0)),
                            sup = l:rad(func.min(l - limits.upper.R, ptXSelector)),
                        }
                    )(l, o) end)
                * function(walls)
                    for i = 1, #walls - 1 do walls[i].limits.inf = walls[i + 1].limits.inf end
                    for i = #walls, 2, -1 do walls[i].limits.sup = walls[i - 1].limits.sup end
                    return walls
                end / 0
            },
            upper = {
                tracks = func.map2(guidelines.upper.tracks, offsets.upper.tracks,
                    attach(limitRads.upper)),
                walls = {
                    attach({
                        inf = limitRads.upper.inf,
                        mid = limits.upper.L:rad(func.min(limits.upper.L - limits.lower.L, ptXSelector)),
                        sup = limitRads.upper.sup,
                    })(limits.upper.L, offsets.upper.walls[1]),
                    attach({
                        inf = limitRads.upper.inf,
                        mid = limits.upper.R:rad(func.min(limits.upper.R - limits.lower.R, ptXSelector)),
                        sup = limitRads.upper.sup,
                    })(limits.upper.R, offsets.upper.walls[#offsets.upper.walls]),
                },
            }
        }
    end
end

local function mPlace(guideline, rad)
    local pt = guideline:pt(rad)
    return coor.rotZ(rad) * coor.transX(pt.x) * coor.transY(pt.y)
end

local function makeFn(model, m)
    local m = m or coor.I()
    return function(obj)
        local coordsGen = arc.coords(obj.guideline, 5)
        local function makeModel(seq, scale)
            return func.map2(func.range(seq, 1, #seq - 1), func.range(seq, 2, #seq), function(rad1, rad2)
                return newModel(model, m, coor.scaleY(0.5 * scale), mPlace(obj.guideline, (rad1 + rad2) * 0.5))
            end)
        end
        return {
            makeModel(coordsGen(normalizeRad(obj.limits.inf), normalizeRad(obj.limits.mid) - normalizeRad(obj.limits.inf))),
            makeModel(coordsGen(normalizeRad(obj.limits.mid), normalizeRad(obj.limits.sup) - normalizeRad(obj.limits.mid)))
        }
    end
end

local function generateStructure(lowerGroup, upperGroup)
    local makeWall = makeFn(mSidePillar, coor.scaleY(1.05))
    local makeRoof = makeFn(mRoof, coor.scaleY(1.05))
    local makeFence = makeFn(mRoofFenceF)
    local makeSideFence = makeFn(mRoofFenceS)
    
    local walls = lowerGroup.walls
    local trackSets = func.p
        * func.map2(func.range(walls, 1, #walls - 1), func.range(walls, 2, #walls),
            function(w1, w2) return func.p
                * func.filter(lowerGroup.tracks, function(t) return t.xOffset < w2.xOffset and t.xOffset > w1.xOffset end)
                * func.bind(func.map, nil, function(t)
                    return func.with(t,
                        {
                            limits = {
                                sup = w2.limits.sup,
                                mid = t.guideline:rad(coor.xy(0, 0)),
                                inf = w1.limits.inf,
                            }
                        }
                ) end)
                / 0
            end)
        * func.flatten / 0
    
    local upperFences = func.map(upperGroup.tracks, function(t)
        return {
            newModel(mSidePillar, coor.rotZ(math.pi * 0.5), coor.scaleX(0.55), coor.transY(-0.25), mPlace(t.guideline, t.limits.inf)),
            newModel(mSidePillar, coor.rotZ(math.pi * 0.5), coor.scaleX(0.55), coor.transY(0.25), mPlace(t.guideline, t.limits.sup)),
        }
    end)
    
    local fences = func.map(trackSets, function(t)
        local m = coor.scaleX(1.091) * coor.transY(0.18) * coor.transZ(-1) * coor.centered(coor.scaleZ, 3.5 / 1.5, coor.xyz(0, 0, 10.75))
        return {
            newModel(mRoofFenceF, m, mPlace(t.guideline, t.limits.inf)),
            newModel(mRoofFenceF, m, coor.flipY(), mPlace(t.guideline, t.limits.sup)),
        }
    end)
    
    local sideFencesL = func.map(func.range(lowerGroup.walls, 1, #lowerGroup.walls - 1), function(t)
        return func.with(t, {
            limits = {
                sup = t.guideline:rad(func.min(upperGroup.walls[1].guideline - t.guideline, ptXSelector)),
                mid = t.guideline:rad(func.min(upperGroup.walls[1].guideline - t.guideline, ptXSelector)),
                inf = t.limits.inf,
            }
        })
    end)
    
    local sideFencesR = func.map(func.range(lowerGroup.walls, 2, #lowerGroup.walls), function(t)
        return func.with(t, {
            limits = {
                inf = t.guideline:rad(func.min(upperGroup.walls[2].guideline - t.guideline, ptXSelector)),
                mid = t.guideline:rad(func.min(upperGroup.walls[2].guideline - t.guideline, ptXSelector)),
                sup = t.limits.sup,
            }
        })
    end)
    
    return {
        func.flatten({
            func.mapFlatten(walls, function(w) return makeWall(w)[1] end),
            func.mapFlatten(trackSets, function(t) return makeRoof(t)[1] end),
            func.map(fences, function(f) return f[1] end),
            func.mapFlatten(sideFencesL, function(t) return makeSideFence(t)[1] end),
            makeSideFence(upperGroup.walls[2])[1],
            makeWall(upperGroup.walls[2])[1],
            func.mapFlatten(upperGroup.tracks, function(t) return makeRoof(t)[1] end),
            func.map(upperFences, function(f) return f[1] end)
        }),
        func.flatten({
            func.mapFlatten(walls, function(w) return makeWall(w)[2] end),
            func.mapFlatten(trackSets, function(t) return makeRoof(t)[2] end),
            func.map(fences, function(f) return f[2] end),
            func.mapFlatten(sideFencesR, function(t) return makeSideFence(t)[2] end),
            makeSideFence(upperGroup.walls[1])[2],
            makeWall(upperGroup.walls[1])[2],
            func.mapFlatten(upperGroup.tracks, function(t) return makeRoof(t)[2] end),
            func.map(upperFences, function(f) return f[2] end)
        }),
    }
end

local generatePolyArcEdge = function(guideline, from, to)
    return func.map(
        arc.coords(guideline, 5)(normalizeRad(from), normalizeRad(to) - normalizeRad(from)),
        function(rad) return (function(p) return {p.x, p.y, 0} end)(guideline:pt(rad)) end)
end

local function defaultParams(params)
    params.trackType = params.trackType or 0
    params.catenary = params.catenary or 1
    params.nbUpperTracks = params.nbUpperTracks or 1
    params.nbLowerTracks = params.nbLowerTracks or 1
    params.xDegDec = params.xDegDec or 2
    params.xDegUni = params.xDegUni or 0
    params.nbPerGroup = params.nbPerGroup or 1
    params.isMir = params.isMir or 0
    params.slope = params.slope or 0
    params.height = params.height or 0
end

local function params()
    return {
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "nbLowerTracks",
            name = _("Number of lower tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6"), },
            defaultIndex = 1
        },
        {
            key = "nbUpperTracks",
            name = _("Number of upper tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6"), },
            defaultIndex = 1
        },
        {
            key = "xDegDec",
            name = _("Crossing angles"),
            values = {_("5"), _("10"), _("20"), _("30"), _("40"), _("50"), _("60"), _("70"), _("80"), },
            defaultIndex = 2
        },
        {
            key = "xDegUni",
            name = "+",
            values = func.seqMap({0, 9}, tostring),
        },
        {
            key = "rLower2",
            name = _("Curvature of lower tracks : Far/Near"),
            values = rTxtList,
            defaultIndex = 4
        },
        {
            key = "rLower1",
            name = "",
            values = rTxtList,
            defaultIndex = 4
        },
        {
            key = "rUpper2",
            name = _("Curvature of upper tracks : Far/Near"),
            values = rTxtList,
            defaultIndex = 4
        },
        {
            key = "rUpper1",
            name = "",
            values = rTxtList,
            defaultIndex = 4
        },
        {
            key = "nbPerGroup",
            name = _("Tracks per group"),
            values = {_("1"), _("2"), _("All")},
            defaultIndex = 1
        },
        {
            key = "isMir",
            name = _("Mirrored"),
            values = {_("No"), _("Yes")},
        },
        {
            key = "slope",
            name = _("Slope(‰)"),
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "height",
            name = _("Altitude Adjustment(m)"),
            values = func.map(heightList, tostring),
            defaultIndex = 3
        }
    }

end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Concrete Flying Junction"),
            description = _("An European style flying junction")
        },
        availability = {
            yearFrom = 1892
        },
        order = 27218,
        params = params(),
        
        updateFn = function(params)
            defaultParams(params)
            
            local result = {}
            
            local deg = listDegree[params.xDegDec + 1] + params.xDegUni
            local rad = math.rad(deg)
            
            local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
            local catenary = params.catenary == 1
            local nbPerGroup = ({1, 2, params.nbLowerTracks + 1})[params.nbPerGroup + 1]
            
            local trackBuilder = trackEdge.builder(catenary, trackType)
            local TLowerTracks = trackBuilder.normal(station.noSnap)
            local TUpperTracks = trackBuilder.nonAligned(station.noSnap)
            local TLowerExtTracks = trackBuilder.normal(snapRule)
            local TUpperExtTracks = trackBuilder.bridge(bridgeType, snapRule)
            
            local retriveR = function(param) return rList[param + 1] * 1000 end
            
            local info1 = {
                lower = {
                    nbTracks = params.nbLowerTracks + 1,
                    r = retriveR(params.rLower1),
                    rad = -0.5 * rad
                },
                upper = {
                    nbTracks = params.nbUpperTracks + 1,
                    r = retriveR(params.rUpper1),
                    rad = 0.5 * rad
                }
            }
            local info2 = {
                lower = {
                    nbTracks = params.nbLowerTracks + 1,
                    r = retriveR(params.rLower2),
                    rad = -0.5 * rad
                },
                upper = {
                    nbTracks = params.nbUpperTracks + 1,
                    r = retriveR(params.rUpper2),
                    rad = 0.5 * rad
                }
            }
            
            local offsets = {
                lower = buildCoors(info1.lower.nbTracks, nbPerGroup),
                upper = buildCoors(info1.upper.nbTracks, info1.upper.nbTracks)
            }
            
            local group1 = part(rad)(info1, offsets)
            local group2 = part(rad)(info2, offsets)
            
            local lowerTracks = generateTrackGroups(group1.lower.tracks, group2.lower.tracks)
            local upperTracks = generateTrackGroups(group1.upper.tracks, group2.upper.tracks, {mpt = coor.transZ(11), mvec = coor.I()})
            
            local upperPolys = func.flatten(
                {
                    generatePolyArcEdge(group1.upper.walls[2].guideline, group1.upper.tracks[1].limits.inf, group1.upper.tracks[1].limits.mid),
                    generatePolyArcEdge(group2.upper.walls[2].guideline, group2.upper.tracks[1].limits.mid, group2.upper.tracks[1].limits.sup),
                    generatePolyArcEdge(group2.upper.walls[1].guideline, group2.upper.tracks[1].limits.sup, group2.upper.tracks[1].limits.mid),
                    generatePolyArcEdge(group1.upper.walls[1].guideline, group1.upper.tracks[1].limits.mid, group1.upper.tracks[1].limits.inf)
                })
            
            local lowerPolys = func.flatten(
                {
                    generatePolyArcEdge(group1.lower.walls[2].guideline, group1.lower.tracks[1].limits.inf, group1.lower.tracks[1].limits.mid),
                    generatePolyArcEdge(group2.lower.walls[2].guideline, group2.lower.tracks[1].limits.mid, group2.lower.tracks[1].limits.sup),
                    generatePolyArcEdge(group2.lower.walls[1].guideline, group2.lower.tracks[1].limits.sup, group2.lower.tracks[1].limits.mid),
                    generatePolyArcEdge(group1.lower.walls[1].guideline, group1.lower.tracks[1].limits.mid, group1.lower.tracks[1].limits.inf)
                })
            
            result = {
                edgeLists =
                {
                    TUpperTracks(upperTracks.normal),
                    TLowerTracks(lowerTracks.normal),
                    TLowerExtTracks(lowerTracks.ext),
                    TUpperExtTracks(upperTracks.ext),
                },
                models = func.flatten({
                    generateStructure(group1.lower, group1.upper)[1],
                    generateStructure(group2.lower, group2.upper)[2],
                }),
                terrainAlignmentLists = {
                    {
                        type = "GREATER",
                        faces = {upperPolys}
                    },
                    {
                        type = "EQUAL",
                        faces = {lowerPolys}
                    }
                }
            }
            
            -- End of generation
            -- Slope, Height, Mirror treatment
            local slope = slopeList[params.slope + 1]
            local ha = heightList[params.height + 1]
            local mirrored = params.isMir == 1
            local mz = coor.transZ(ha)
            local mr = coor.rotX(math.atan(slope * 0.001))
            local mf = mirrored and coor.flipX() or coor.I()
            local mpt = mf * mr * mz
            local mvec = mf * mr
            
            local mapEdgeList = function(edgeList)
                return func.with(edgeList, {edges = func.map(edgeList.edges, coor.applyEdge(mpt, mvec))})
            end
            
            local mapModel = function(model) return func.with(model, {transf = model.transf * mpt}) end
            
            local mapTerrainList = function(ta)
                local mapTerrain = function(t) return (coor.tuple2Vec(t) .. mpt):toTuple() end
                local mapFaces = function(faces) return (mirrored and func.rev or func.nop)(func.map(faces, mapTerrain)) end
                return func.with(ta, {faces = func.map(ta.faces, mapFaces)})
            end
            
            return func.with(result,
                {
                    edgeLists = func.map(result.edgeLists, mapEdgeList),
                    models = func.map(result.models, mapModel),
                    terrainAlignmentLists = func.map(result.terrainAlignmentLists, mapTerrainList),
                    groundFaces = {},
                    terminalGroups = {},
                    cost = 1000,
                    maintenanceCost = 1000 / 6
                })
        end
    }

end
