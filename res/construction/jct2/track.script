local func = require "jct/func"
local coor = require "jct/coor"
local pipe = require "jct/pipe"
local arc = require "jct/coorarc"
local line = require "jct/coorline"
local jct = require "jct2"
local quat = require "jct/quaternion"
local livetext = require "jct/livetext"
local dump = require "luadump"

local insert = table.insert

local preProcessAdd = function(modules, change, classedModules, info)
    local maxId = func.max(func.keys(classedModules))

-- if (info.data == -1) then
--     local id = info.id
--     local slotId = classedModules[id].slotId
--     modules[slotId].name = change.module.name
-- else
--     local grid = jct.octa(modules, classedModules)
--     local refPos = modules[classedModules[info.id].slotId].info.pos
--     local pos = ({
--         [1] = coor.xyz(0, 1, 0),
--         [3] = coor.xyz(1, 0, 0),
--         [5] = coor.xyz(0, -1, 0),
--         [7] = coor.xyz(-1, 0, 0)
--     })[info.data] + refPos
--     local x, y, z = pos.x, pos.y, pos.z
--     local octa = {
--         [5] = grid[z][x] and grid[z][x][y - 1] or nil,
--         [1] = grid[z][x] and grid[z][x][y + 1] or nil,
--         [7] = grid[z][x - 1] and grid[z][x - 1][y] or nil,
--         [3] = grid[z][x + 1] and grid[z][x + 1][y] or nil,
--         [6] = grid[z][x - 1] and grid[z][x - 1][y - 1] or nil,
--         [4] = grid[z][x + 1] and grid[z][x + 1][y - 1] or nil,
--         [8] = grid[z][x - 1] and grid[z][x - 1][y + 1] or nil,
--         [2] = grid[z][x + 1] and grid[z][x + 1][y + 1] or nil,
--     }
--     local function isTrack(pos)
--         return octa[pos] and (modules[octa[pos]].metadata.isTrack or modules[octa[pos]].metadata.isStreet or modules[octa[pos]].metadata.isPlaceholder)
--     end
--     local function isPlatform(pos)
--         return octa[pos] and modules[octa[pos]].metadata.isPlatform
--     end
--     local ref = {}
--     if isTrack(1) then
--         ref = {next = true}
--     elseif isTrack(5) then
--         ref = {prev = true}
--     elseif isTrack(3) then
--         ref = {right = true}
--     elseif isTrack(7) then
--         ref = {left = true}
--     elseif isPlatform(1) then
--         ref = {next = true}
--     elseif isPlatform(5) then
--         ref = {prev = true}
--     elseif isPlatform(3) then
--         ref = {right = true}
--     elseif isPlatform(7) then
--         ref = {left = true}
--     end
--     local newInfo = {
--         id = maxId + 1,
--         type = change.module.metadata.typeId,
--         pos = pos,
--         length = 20,
--         width = change.module.metadata.width,
--         ref = ref,
--         extraHeight = (isTrack(5) and modules[octa[5]].info.extraHeight) or (isTrack(1) and modules[octa[1]].info.extraHeight) or nil
--     }
--     local slotId, dataIds = jct.slotIds(newInfo)
--     modules[slotId] = change.module
--     for m, slotIds in pairs(dataIds) do
--         for _, slotId in ipairs(slotIds) do
--             modules[slotId] = {
--                 metadata = {isData = true},
--                 name = string.format("jct2/data/%s.module", m),
--                 updateScript = {
--                     fileName = "",
--                     params = {}
--                 },
--                 variant = 0
--             }
--         end
--     end
-- end
end

local preProcessRemove = function(modules, change, classedModules, info)
    -- if info.id ~= 1 then
    --     jct.octa(modules, classedModules)
    --     local info = modules[change.slotId].info
    --     local octaModules = {}
    --     for i = 1, 8 do
    --         octaModules[i] = info.octa[i] and modules[info.octa[i]] or false
    --     end
    --     if not (
    --         octaModules[1] and octaModules[1].info.ref.prev
    --         or octaModules[5] and octaModules[5].info.ref.next
    --         or octaModules[3] and octaModules[3].info.ref.left
    --         or octaModules[7] and octaModules[7].info.ref.right)
    --     then
    --         modules[change.slotId] = nil
    --         for slotId, m in pairs(modules) do
    --             local __, moduleId = jct.slotInfo(slotId)
    --             if moduleId == info.id then
    --                 modules[slotId] = nil
    --             end
    --         end
    --     end
    -- end
    end

local slotSetup = function(params, result, slotId)
    local module = params.modules[slotId]
    
    table.insert(result.slots, {
        id = slotId,
        transf = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
        type = "jct_track",
        spacing = {0, 0, 0, 0}
    })

end

local fzGen = function(initHeight, finalHeight)
    return function(initRad, finalRad)
        local ln = line.byPtPt(
            coor.xy(initRad, initHeight),
            coor.xy(finalRad, finalHeight)
        )
        return function(rad) return (ln - line.byVecPt(coor.xy(0, 1), coor.xy(rad, 0))).y end
    end
end

local fsGen = function(slope)
    return function(initRad, finalRad) return function(_) return slope end end
end

local ptXSelector = function(lhs, rhs) return lhs:length2() < rhs:length2() end

local function gridization(pos, data)
    local x, y, z = pos.x, pos.y, pos.z
    local slotId = data.grid[z][y][x]
    
    local m = data.modules[slotId]
    local info = m.info
    dump()(info)
    if x == 0 and (y == 1 or y == -1) then
        local radius = info.radius
        local xRad = info.xRad
        if z == 0 then
            local fz = fzGen(0, 0)
            local fs = fsGen(0)
            info.arcPacker = jct.arcPacker(radius, -xRad * 0.5, fz, fs)
        else
            local fz = fzGen(info.height, info.height)
            local fs = fsGen(0)
            info.arcPacker = jct.arcPacker(radius, xRad * 0.5, fz, fs)
        end
        info.offset = 0
    elseif x == 0 and y > 1 then
        local refSlotId = data.grid[z][y - 1][0]
        info.arcPacker = data.modules[refSlotId].info.arcPacker
        info.offset = 0
    elseif x == 0 and y < -1 then
        local refSlotId = data.grid[z][y + 1][0]
        info.arcPacker = data.modules[refSlotId].info.arcPacker
        info.offset = 0
    elseif x < 0 then
        local refSlotId = data.grid[z][y][x + 1]
        local ref = data.modules[refSlotId]
        info.arcPacker = ref.arcPacker
        info.offset = ref.info.offset - ref.metadata.width * 0.5 - m.metadata.width * 0.5
    elseif x > 0 then
        local refSlotId = data.grid[z][y][x - 1]
        local ref = data.modules[refSlotId]
        info.arcPacker = data.modules[refSlotId].info.arcPacker
        info.offset = ref.info.offset + ref.metadata.width * 0.5 + m.metadata.width * 0.5
    end
    
    coroutine.yield()
    
    local arc, initRad, fn = info.arcPacker(info.offset)(m.metadata.width)
    info.arcs = {arc = arc, initRad = initRad, fn = fn}
    
    coroutine.yield()
    
    if x == 0 and (y == 1 or y == -1) then
        local z1Max = data.modules[data.grid[1][y][func.max(func.keys(data.grid[1][y]))]].info
        local z1Min = data.modules[data.grid[1][y][func.min(func.keys(data.grid[1][y]))]].info
        local z0Max = data.modules[data.grid[0][y][func.max(func.keys(data.grid[0][y]))]].info
        local z0Min = data.modules[data.grid[0][y][func.min(func.keys(data.grid[0][y]))]].info
        
        if y == 1 then
            local ptXSup = func.min(z0Min.arcs.arc[1] - z1Max.arcs.arc[2], ptXSelector)
            info.arcs.ptXSup = ptXSup
        else 
            local ptXSup = func.min(z0Max.arcs.arc[2] - z1Min.arcs.arc[1], ptXSelector)
            info.arcs.ptXSup = ptXSup
        end
        info.arcs.fn = info.arcs.fn(info.arcs.ptXSup)
        info.fnArc = info.arcs.fn(info.arcs.ptXSup)
    elseif x < 0 then
        local refSlotId = data.grid[z][y][x + 1]
        local ref = data.modules[refSlotId].info
        
        info.arcs.ptXSup = ref.arcs.ptXSup
        info.arcs.fn = info.arcs.fn(info.arcs.ptXSup)
        
        info.fnArc = info.arcs.fn(info.arcs.ptXSup)
    elseif x > 0 then
        local refSlotId = data.grid[z][y][x - 1]
        local ref = data.modules[refSlotId].info
        
        info.arcs.ptXSup = ref.arcs.ptXSup
        info.arcs.fn = info.arcs.fn(info.arcs.ptXSup)
        
        info.fnArc = info.arcs.fn(info.arcs.ptXSup)
    else
        
        end
end

---@param modules table<slotid, module>
---@param classified classified_modules
---@param slotId slotid
---@param params any
local postClassify = function(modules, classified, slotId, params)
    modules[slotId].info.height = modules[slotId].info.pos.z == 1 and params.tunnelHeight or 0
    modules[slotId].info.xRad = params.xRad

    modules[slotId].info.transf = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}
    
    if modules[slotId].info.straight then
        modules[slotId].info.radius = jct.infi
    end
end

function data()
    return {
        preProcessAdd = preProcessAdd,
        preProcessRemove = preProcessRemove,
        slotSetup = slotSetup,
        preClassify = jct.preClassify,
        postClassify = postClassify,
        getModelsFn = function(params)
            return {}
        end,
        gridization = gridization
    }

end
