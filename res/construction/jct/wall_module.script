local func = require "jct/func"
local coor = require "jct/coor"
local pipe = require "jct/pipe"
local general = require "jct/general"
local jct = require "jct"

-- local dump = require "dump"
local wallTypes = {
    "concrete_wall",
    "brick_wall",
    "brick_2_wall"
}

function data()
    return {
        updateFn = function(result, transform, tag, slotId, addModelFn, params, closureParams)
            local wallType = closureParams.wallType or wallTypes[params.wallType + 1]
            local wallWidth = closureParams.wallWidth or 0.5
            
            local modelWall = ("jct/%s"):format(wallType)
            local modelFence = ("jct/%s_fence"):format(wallType)
            local withTag = general.withTag(tag)
            local info = jct.slotInfo(slotId)
            local isZigZag = params.extType == 0
            
            local config = info.isUpper and result.config.upper or result.config.lower
            
            local arcs = func.filter(config.arcs[info.pos.x], pipe.select(isZigZag and "zigzag" or "aligned"))
            local coords = func.map(arcs, function(arc)
                local biLatCoords = jct.biLatCoords(5, arc.arc)
                local isRev = arc.isRev
                local lc, rc, lce, rce = biLatCoords(-wallWidth * 0.5, wallWidth * 0.5, -wallWidth * 0.5 - 0.5, wallWidth * 0.5 + 0.5)
                if result.config.mirrored then
                    lc, rc = rc, lc
                    lce, rce = rce, lce
                end
                local op = isRev and pipe.rev() or pipe.noop()
                lc, rc = op(lc), op(rc)
                lce, rce = op(lce), op(rce)
                return {lc = jct.interlace(lc), rc = jct.interlace(rc), lce = jct.interlace(lce), rce = jct.interlace(rce)}
            end)
            
            local isLeftTrack = config.modules[info.pos.x - 1] and config.modules[info.pos.x - 1].type == "jct_track"
            local isRighTrack = config.modules[info.pos.x + 1] and config.modules[info.pos.x + 1].type == "jct_track"
            
            table.insert(result.colliders, {
                type = "POINT_CLOUD",
                params = {
                    points = pipe.new * func.map(coords, function(coord)
                        return func.map2(coord.lc, coord.rc, function(l, r) return l.i:avg(l.s):avg(r.i:avg(r.s)) end)
                    end)
                    * pipe.flatten()
                    * pipe.map(coor.vec2Tuple)
                }
            
            }
            )
            if isZigZag then
                result.models = result.models + pipe.new
                    * func.map2(coords, arcs, function(coord, arc)
                        return pipe.new
                            + (arc.wall and func.map2(coord.lc, coord.rc, function(baseL, baseR) return config.build.wall(nil, modelWall, baseL, baseR) * withTag end) or {})
                            + (arc.fence and func.map2(coord.lc, coord.rc, function(baseL, baseR) return config.build.fence(nil, modelFence, baseL, baseR) * withTag end) or {})
                            + (arc.paving and func.map2(coord.lc, coord.rc, function(baseL, baseR) return config.build.surface(nil, "jct/surface", baseL, baseR) * withTag end) or {})
                    end)
                    * pipe.flatten()
                    * pipe.flatten()
                if wallType == "concrete_wall" and not info.isUpper then
                    result.models = result.models + pipe.new
                        * func.map2(coords, config.arcs[info.pos.x], function(coord, arc)
                            return arc.onlyFence and {} or pipe.new
                                + (arc.cornerLeft and func.map2(coord.lce, coord.lc, function(baseL, baseR) return config.build.corner(nil, "jct/concrete_corner_left", baseL, baseR) * withTag end) or {})
                                + (arc.cornerRight and func.map2(coord.rc, coord.rce, function(baseL, baseR) return config.build.corner(nil, "jct/concrete_corner_right", baseL, baseR) * withTag end) or {})
                        end)
                        * pipe.flatten()
                        * pipe.flatten()
                end
            else
                if info.isUpper then
                    result.models = result.models + pipe.new
                        * func.map2(coords, arcs, function(coord, arc)
                            return pipe.new
                                + (arc.wall and func.map2(coord.lc, coord.rc, function(baseL, baseR) return config.build.wall(nil, modelWall, baseL, baseR) * withTag end) or {})
                                + (arc.fence and func.map2(coord.lc, coord.rc, function(baseL, baseR) return config.build.fence(nil, modelFence, baseL, baseR) * withTag end) or {})
                        end)
                        * pipe.flatten()
                        * pipe.flatten()
                else
                    result.models = result.models + pipe.new
                        * func.map2(coords, arcs, function(coord, arc)
                            return arc.wall and func.map2(coord.lc, coord.rc, function(baseL, baseR) return config.build.wall(nil, modelWall, baseL, baseR) * withTag end) or {}
                        end)
                        * pipe.flatten()
                        * pipe.flatten()
                end
            end
        end,
        
        getModelsFn = function(params)
            return {}
        end
    }

end
