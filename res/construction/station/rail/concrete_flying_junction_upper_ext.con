local laneutil = require "laneutil"
local paramsutil = require "paramsutil"
local func = require "flyingjunction/func"
local coor = require "flyingjunction/coor"
local trackEdge = require "flyingjunction/trackedge"
local line = require "flyingjunction/coorline"
local arc = require "flyingjunction/coorarc"
local station = require "flyingjunction/stationlib"
local pipe = require "flyingjunction/pipe"
local junction = require "junction"

local dump = require "datadumper"

local mSidePillar = "station/concrete_flying_junction/infra_junc_pillar_side.mdl"
local mRoofFenceF = "station/concrete_flying_junction/infra_junc_roof_fence_front.mdl"
local mRoofFenceS = "station/concrete_flying_junction/infra_junc_roof_fence_side.mdl"
local mRoof = "station/concrete_flying_junction/infra_junc_roof.mdl"
local bridgeType = "z_concrete_flying_junction.lua"

local listDegree = {5, 10, 20, 30, 40, 50, 60, 70, 80}
local rList = {-0.1, -0.3, -0.5, -1, 1e5, 1, 0.5, 0.3, 0.1}
local rTxtList = {"●", "●", "•", "∙", "0", "∙", "•", "●", "●"}

local slopeList = {10, 20, 25, 30, 35, 40, 50, 60, 70}
local heightList = {-5, -2.5, -0.5, 0, 0.5, 2.5, 5}

local snapRule = function(e) return func.filter(func.seq(0, #e - 1), function(e) return e % 4 == 0 or (e - 3) % 4 == 0 end) end


local ptXSelector = function(lhs, rhs) return lhs:length() < rhs:length() end

local function attach(limits)
    return function(l, x)
        return {
            limits = limits,
            xOffset = x,
            guideline = l,
        }
    end
end

local function defaultParams(params)
    params.trackType = params.trackType or 0
    params.catenary = params.catenary or 1
    params.nbUpperTracks = params.nbUpperTracks or 1
    params.slope = params.slope or 0
    params.rUpper = params.rUpper or 4
end

local function params()
    return {
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "nbUpperTracks",
            name = _("Number of upper tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6"), },
            defaultIndex = 1
        },
        {
            key = "rUpper",
            name = _("Curvature of upper tracks : Near"),
            values = rTxtList,
            defaultIndex = 4
        },
        {
            key = "slope",
            name = _("Slope(‰)"),
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        }
    }

end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Concrete Flying Junction"),
            description = _("An European style flying junction")
        },
        availability = {
            yearFrom = 1892
        },
        order = 27218,
        params = params(),
        
        updateFn = function(params)
            defaultParams(params)
            
            local result = pipe.new
            
            local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
            local catenary = params.catenary == 1
            local fixedHeight = 11
            local slope = slopeList[params.slope + 1] * 0.001
            local length = 11 / slope
            local slopeRad = math.atan(slope)
            local slopeR = 100
            
            
            local trackBuilder = trackEdge.builder(catenary, trackType)
            local TUpperTracks = trackBuilder.nonAligned(station.noSnap)
            
            
            local transitionLength = slopeR * slopeRad
            
            local nbTracks = params.nbUpperTracks + 1
            local r = rList[params.rUpper + 1] * 1000
            local rad = length / r
            local tRad = transitionLength / length * rad
            
            local offsets = junction.buildCoors(nbTracks, nbTracks)
            
            local tracks = junction.fArcs(offsets.tracks, 0, r)
            local walls = junction.fArcs(offsets.walls, 0, r)
            
            local limits =
                {
                    L = walls[1],
                    R = walls[#walls]
                }
            
            
            local ar = pipe.new
                * junction.fArcs(offsets.tracks, 0, r)
                * pipe.map(function(t) return
                    {
                        {
                            limits =
                            {
                                inf = (r > 0 and math.pi or 0) + rad,
                                mid = (r > 0 and math.pi or 0) + rad - tRad,
                                sup = (r > 0 and math.pi or 0) + 0.5 * rad,
                            },
                            guideline = t,
                        },
                        {
                            limits =
                            {
                                inf = (r > 0 and math.pi or 0) + 0.5 * rad,
                                mid = (r > 0 and math.pi or 0) + tRad,
                                sup = (r > 0 and math.pi or 0),
                            },
                            guideline = t,
                        }
                    } end)
            
            local tG =
                pipe.new
                * func.map(ar, function(ar) return {junction.generateArc(ar[1]), junction.generateArc(ar[2])} end)
                * pipe.map(function(ar) return {ar[1][3], ar[1][1], ar[1][2], ar[2][1], ar[2][2], ar[2][4]} end)
                * pipe.map(function(ar)
                    local dt = slopeR * (1 - math.cos(tRad))
                    return pipe.new
                        * {-11, -11, -11 + dt, -5.5, -dt, 0, 0}
                        * pipe.zip({0, 0, slope, slope, slope, 0, 0}, {"z", "s"})
                        * function(lz) return lz
                            * pipe.range(1, #lz - 1)
                            * pipe.map2(lz * pipe.range(2, #lz), function(a, b) return func.map({a.z, b.z, a.s, b.s}, coor.transZ) end)
                        end
                        * pipe.map2(ar, function(nz, ar) return func.map2(ar, nz, coor.apply) end)
                end)
                * pipe.map(pipe.map(pipe.map(coor.vec2Tuple)))
                * pipe.map(pipe.zip({{true, false}, {false, false}, {false, false}, {false, false}, {false, false}, {false, true}}, {"edge", "snap"}))
                * pipe.flatten()
                * station.prepareEdges
            
            local x =
                {
                    edgeLists = {TUpperTracks(tG)},
                    models = {},
                    terrainAlignmentLists = {
                        {
                            type = "EQUAL",
                            faces = {}
                        }
                    },
                    groundFaces = {},
                    terminalGroups = {},
                    cost = 1000,
                    maintenanceCost = 1000 / 6
                }
            
            return x
        
        
        end
    }

end
