local laneutil = require "laneutil"
local paramsutil = require "paramsutil"
local func = require "func"
local coor = require "coor"
local trackEdge = require "trackedge"
local line = require "coorline"
local arc = require "coorarc"
local station = require "stationlib"

local dump = require "datadumper"

local mSidePillar = "station/concrete_flying_junction/infra_junc_pillar_side.mdl"
local mRoofFenceF = "station/concrete_flying_junction/infra_junc_roof_fence_front.mdl"
local mRoofFenceS = "station/concrete_flying_junction/infra_junc_roof_fence_side.mdl"
local mRoof = "station/concrete_flying_junction/infra_junc_roof.mdl"
local bridgeType = "z_concrete_flying_junction.lua"

local listDegree = {5, 10, 20, 30, 40, 50, 60, 70, 80}
local rList = {-1, -0.5, -0.3, -0.1, 0, 0.1, 0.3, 0.5, 1}

local snapRule = function(e) return func.filter(func.seq(0, #e - 1), function(e) return e % 4 == 0 or (e - 3) % 4 == 0 end) end

local newModel = function(m, ...)
    return {
        id = m,
        transf = coor.mul(...)
    }
end

function buildCoors(numTracks, groupSize)
    local function builder(xOffsets, uOffsets, baseX, nbTracks)
        local function caller(n)
            return builder(
                func.concat(xOffsets, func.seqMap({1, n}, function(n) return baseX - 0.5 * station.trackWidth + n * station.trackWidth end)),
                func.concat(uOffsets, {baseX + n * station.trackWidth + 0.5}),
                baseX + n * station.trackWidth + 1,
                nbTracks - n)
        end
        if (nbTracks == 0) then
            local offset = function(o) return o - baseX * 0.5 end
            return {tracks = func.map(xOffsets, offset), walls = func.map(uOffsets, offset)}
        elseif (nbTracks < groupSize) then
            return caller(nbTracks)
        else
            return caller(groupSize)
        end
    end
    return builder({}, {0.5}, 1, numTracks)
end

local slopeList = {0, 10, 20, 25, 30, 35, 40, 50, 60}
local heightList = {0.5, 1, 1.5, 2, 4, 6, 8, 10}
local slopeRad = func.mapPair(
    func.concat(slopeList, func.map(slopeList, function(s) return -s end)),
    function(s) return s, math.atan(s * 0.001) end)
local slopeMRotX = func.mapValues(slopeRad, coor.rotX)

local generateLineSegment = function(line)
    local toXyz = function(pt) return coor.xyz(pt.x, pt.y, 0) end
    local sup = toXyz(line.limits.sup)
    local mid = toXyz(line.limits.mid)
    local inf = toXyz(line.limits.inf)
    
    local halfLength = sup % inf
    local vector = (sup - inf):normalized() * halfLength
    
    return laneutil.makeLanes({
        {inf:toTuple(), mid:toTuple(), vector:toTuple(), vector:toTuple()},
        {mid:toTuple(), sup:toTuple(), vector:toTuple(), vector:toTuple()},
    })

end

local generateArc = function(arc)
    local toXyz = function(pt) return coor.xyz(pt.x, pt.y, 0) end
    
    local radSup = arc.limits.sup
    local radMid = arc.limits.mid
    local radInf = arc.limits.inf
    
    local sup = toXyz(arc.guideline:pt(radSup))
    local inf = toXyz(arc.guideline:pt(radInf))
    local mid = toXyz(arc.guideline:pt(radMid))
    
    local toVector = function(rad) return coor.xyz(0, (arc.limits.mid > math.pi * 0.5 or arc.limits.mid < -math.pi * 0.5) and -1 or 1, 0) .. coor.rotZ(rad) end
    
    local vecSup = toVector(radSup)
    local vecInf = toVector(radInf)
    local vecMid = toVector(radMid)
    
    return laneutil.makeLanes({
        {inf:toTuple(), mid:toTuple(), vecInf:toTuple(), vecMid:toTuple()},
        {mid:toTuple(), sup:toTuple(), vecMid:toTuple(), vecSup:toTuple()},
    })
end



local generateTrackGroups = function(tracks1, tracks2, trans)
    trans = trans or {mpt = coor.I(), mvec = coor.I()}
    return func.flatten(func.map2(tracks1, tracks2,
        function(t1, t2) return
            coor.applyEdges(trans.mpt, trans.mvec)(func.concat(
                func.range(t1:gen(), 1, 2),
                func.range(t2:gen(), 3, 4)
        ))
        end))
end

local fLines = function(offsets, rad)
    return func.map(offsets, function(x) return
        line.byVecPt(
            coor.xyz(0, 1, 0) .. coor.rotZ(rad),
            coor.xyz(x, 0, 0) .. coor.rotZ(rad)
    )
    end
)
end

local fArcs = function(offsets, rad, r)
    return func.map(offsets, function(x)
        return arc.byOR(
            coor.xyz(r, 0, 0) .. coor.rotZ(rad),
            math.abs(r - x)
    ) end
)
end

local function attach(limits)
    return function(l, x)
        return {
            limits = limits,
            xOffsets = x,
            guideline = l,
            gen = l.o and generateArc or generateLineSegment
        }
    end
end

local function lineByLine(offsets, guidelines, limits)
    local limitVecs = {
        lower = {
            sup = (limits.lower.L - limits.upper.R) - (limits.lower.L - guidelines.lower.level),
            inf = (limits.lower.R - limits.upper.L) - (limits.lower.R - guidelines.lower.level)
        },
        upper = {
            sup = (limits.upper.R - limits.lower.L) - (limits.upper.R - guidelines.upper.level),
            inf = (limits.upper.L - limits.lower.R) - (limits.upper.L - guidelines.upper.level)
        }
    }
    
    return {
        lower = {
            tracks = func.map2(guidelines.lower.tracks, offsets.lower.tracks, function(l, x)
                return attach({
                    sup = (l - guidelines.lower.level) + limitVecs.lower.sup,
                    mid = (l - guidelines.lower.level),
                    inf = (l - guidelines.lower.level) + limitVecs.lower.inf
                })(l, x) end),
            walls = func.map2(guidelines.lower.walls, offsets.lower.walls, function(l, x)
                return attach({
                    sup = (l - limits.upper.R),
                    mid = (l - guidelines.lower.level),
                    inf = (l - limits.upper.L)
                })(l, x) end)
        },
        upper = {
            tracks = func.map2(guidelines.upper.tracks, offsets.upper.tracks, function(l, x)
                return attach({
                    sup = (l - guidelines.upper.level) + limitVecs.upper.sup,
                    mid = (l - guidelines.upper.level),
                    inf = (l - guidelines.upper.level) + limitVecs.upper.inf
                })(l, x) end),
            walls = func.map2(guidelines.upper.walls, offsets.upper.walls, function(l, x)
                return attach({
                    sup = (l - limits.lower.L),
                    mid = (l - guidelines.upper.level),
                    inf = (l - limits.lower.R)
                })(l, x) end)
        }
    }
end

local ptXSelector = function(lhs, rhs) return lhs:length() < rhs:length() end

local function lineByArc(offsets, guidelines, limits)
    local xer = function(lhs, rhs) return func.min(lhs / rhs, ptXSelector) end
    
    local limitVecs = {
        lower = {
            sup = xer(limits.upper.R, limits.lower.L) - (limits.lower.L - guidelines.lower.level),
            inf = xer(limits.upper.L, limits.lower.R) - (limits.lower.R - guidelines.lower.level)
        },
        upper = {
            sup = limits.upper.R:rad(xer(limits.upper.R, limits.lower.L)),
            mid = limits.upper.R:rad(coor.xy(0, 0)),
            inf = limits.upper.L:rad(xer(limits.upper.L, limits.lower.R))
        }
    }
    
    return {
        lower = {
            tracks = func.map2(guidelines.lower.tracks, offsets.lower.tracks, function(l, x)
                return attach({
                    sup = (l - guidelines.lower.level) + limitVecs.lower.sup,
                    mid = (l - guidelines.lower.level),
                    inf = (l - guidelines.lower.level) + limitVecs.lower.inf
                })(l, x) end),
            walls = func.map2(guidelines.lower.walls, offsets.lower.walls, function(l, x)
                return attach({
                    sup = xer(l, limits.upper.R),
                    mid = (l - guidelines.lower.level),
                    inf = xer(l, limits.upper.L)
                })(l, x) end)
        },
        upper = {
            tracks = func.map2(guidelines.upper.tracks, offsets.upper.tracks,
                attach(limitVecs.upper)),
            walls = func.map2(guidelines.upper.walls, offsets.upper.walls,
                attach(limitVecs.upper))
        }
    }
end

local function arcByLine(offsets, guidelines, limits)
    local xer = function(lhs, rhs) return func.min(lhs / rhs, ptXSelector) end
    
    local limitVecs = {
        lower = {
            inf = limits.lower.R:rad(xer(limits.lower.R, limits.upper.L)),
            mid = limits.lower.R:rad(coor.xy(0, 0)),
            sup = limits.lower.L:rad(xer(limits.lower.L, limits.upper.R))
        },
        upper = {
            sup = xer(limits.lower.R, limits.upper.L) - (limits.upper.L - guidelines.upper.level),
            inf = xer(limits.lower.L, limits.upper.R) - (limits.upper.R - guidelines.upper.level)
        }
    }
    
    return {
        lower = {
            tracks = func.map2(guidelines.lower.tracks, offsets.lower.tracks,
                attach(limitVecs.lower)),
            walls = func.map2(guidelines.lower.walls, offsets.lower.walls,
                attach(limitVecs.lower))
        },
        upper = {
            tracks = func.map2(guidelines.upper.tracks, offsets.upper.tracks, function(l, x)
                return attach({
                    sup = (l - guidelines.upper.level) + limitVecs.upper.sup,
                    mid = (l - guidelines.upper.level),
                    inf = (l - guidelines.upper.level) + limitVecs.upper.inf
                })(l, x) end),
            walls = func.map2(guidelines.upper.walls, offsets.upper.walls, function(l, x)
                return attach({
                    sup = xer(l, limits.lower.R),
                    mid = (l - guidelines.upper.level),
                    inf = xer(l, limits.lower.L)
                })(l, x) end)
        },
    }
end

local function arcByArc(offsets, guidelines, limits)
    local limitVecs = {
        lower = {
            inf = limits.lower.R:rad(func.min(limits.lower.R - limits.upper.L, ptXSelector)),
            mid = limits.lower.R:rad(coor.xy(0, 0)),
            sup = limits.lower.L:rad(func.min(limits.lower.L - limits.upper.R, ptXSelector)),
        },
        upper = {
            sup = limits.upper.R:rad(func.min(limits.upper.R - limits.lower.L, ptXSelector)),
            mid = limits.upper.R:rad(coor.xy(0, 0)),
            inf = limits.upper.L:rad(func.min(limits.upper.L - limits.lower.R, ptXSelector)),
        }
    }
    
    return {
        lower = {
            tracks = func.map2(guidelines.lower.tracks, offsets.lower.tracks,
                attach(limitVecs.lower)),
            walls = func.map2(guidelines.lower.walls, offsets.lower.walls,
                attach(limitVecs.lower))
        },
        upper = {
            tracks = func.map2(guidelines.upper.tracks, offsets.upper.tracks,
                attach(limitVecs.upper)),
            walls = func.map2(guidelines.upper.walls, offsets.upper.walls,
                attach(limitVecs.upper))
        }
    }
end

local selectGuideliner = function(r) return (r == 0) and fLines or func.bind(fArcs, nil, nil, r) end

local minimalR = function(offsets, info)
    local offsetLower = {offsets.lower.walls[1], offsets.lower.walls[#offsets.lower.walls]}
    local offsetUpper = {offsets.upper.walls[1], offsets.upper.walls[#offsets.upper.walls]}
    
    local function incr(r)
        return r == 0 and 0 or (r > 0 and r + 1 or r - 1)
    end
    
    local function calculate(rLower, rUpper)
        if (rUpper == 0 and rLower == 0) then return rLower, rUpper end
        
        local upperGuideliner = selectGuideliner(rUpper)
        local lowerGuideliner = selectGuideliner(rLower)
        
        local lowerGuideline = lowerGuideliner(offsetLower, info.lower.rad)
        local upperGuideline = upperGuideliner(offsetUpper, info.upper.rad)
        
        local resultTest = (function()
            if (rUpper ~= 0 and rLower ~= 0) then
                return (
                    #(lowerGuideline[1] - upperGuideline[1]) > 1 and
                    #(lowerGuideline[1] - upperGuideline[2]) > 1 and
                    #(lowerGuideline[2] - upperGuideline[1]) > 1 and
                    #(lowerGuideline[2] - upperGuideline[2]) > 1
            )
            else
                return (
                    #(lowerGuideline[1] / upperGuideline[1]) > 1 and
                    #(lowerGuideline[1] / upperGuideline[2]) > 1 and
                    #(lowerGuideline[2] / upperGuideline[1]) > 1 and
                    #(lowerGuideline[2] / upperGuideline[2]) > 1
            )
            end
        end)()
        
        if (resultTest) then
            return rLower, rUpper
        else
            return calculate(incr(rLower), rLower == rUpper and rUpper or incr(rUpper))
        end
    end
    return calculate(info.lower.r, info.upper.r)
end

local function part(rad)
    return function(info, offsets)
        info.lower.r, info.upper.r = minimalR(offsets, info)
        
        info.lower.guideliner = selectGuideliner(info.lower.r)
        info.upper.guideliner = selectGuideliner(info.upper.r)
        
        local guidelines =
            {
                lower = {
                    tracks = info.lower.guideliner(offsets.lower.tracks, info.lower.rad),
                    walls = info.lower.guideliner(offsets.lower.walls, info.lower.rad),
                    level = line.byVecPt(coor.xy(math.cos(info.lower.rad), math.sin(info.lower.rad)), coor.o)
                },
                upper = {
                    tracks = info.upper.guideliner(offsets.upper.tracks, info.upper.rad),
                    walls = info.upper.guideliner(offsets.upper.walls, info.upper.rad),
                    level = line.byVecPt(coor.xy(math.cos(info.upper.rad), math.sin(info.upper.rad)), coor.o)
                }
            }
        
        local limits = {
            lower = {L = guidelines.lower.walls[1], R = guidelines.lower.walls[#guidelines.lower.walls]},
            upper = {L = guidelines.upper.walls[1], R = guidelines.upper.walls[#guidelines.upper.walls]}
        }
        
        if (info.lower.r == 0 and info.upper.r == 0) then
            return lineByLine(offsets, guidelines, limits)
        elseif (info.lower.r == 0 and info.upper.r ~= 0) then
            return lineByArc(offsets, guidelines, limits)
        elseif (info.lower.r ~= 0 and info.upper.r == 0) then
            return arcByLine(offsets, guidelines, limits)
        else
            return arcByArc(offsets, guidelines, limits)
        end
    end
end

local function defaultParams(params)
    params.trackType = params.trackType or 0
    params.catenary = params.catenary or 1
    params.nbUpperTracks = params.nbUpperTracks or 1
    params.nbLowerTracks = params.nbLowerTracks or 1
    params.xDegDec = params.xDegDec or 2
    params.xDegUni = params.xDegUni or 0
    params.nbPerGroup = params.nbPerGroup or 1
    params.isMir = params.isMir or 0
    params.slope = params.slope or 0
    params.height = params.height or 0
end

local function params()
    return {
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "nbLowerTracks",
            name = _("Number of lower tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6"), },
            defaultIndex = 1
        },
        {
            key = "nbUpperTracks",
            name = _("Number of upper tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6"), },
            defaultIndex = 1
        },
        {
            key = "xDegDec",
            name = _("Crossing angles"),
            values = {_("5"), _("10"), _("20"), _("30"), _("40"), _("50"), _("60"), _("70"), _("80"), },
            defaultIndex = 2
        },
        {
            key = "xDegUni",
            name = _("+"),
            values = func.seqMap({0, 9}, tostring),
        },
        {
            key = "rLower1",
            name = _("R of lower tracks"),
            values = func.map(rList, tostring),
            defaultIndex = 4
        },
        {
            key = "rUpper1",
            name = _("R of upper tracks"),
            values = func.map(rList, tostring),
            defaultIndex = 4
        },
        {
            key = "rLower2",
            name = _("R of lower tracks"),
            values = func.map(rList, tostring),
            defaultIndex = 4
        },
        {
            key = "rUpper2",
            name = _("R of upper tracks"),
            values = func.map(rList, tostring),
            defaultIndex = 4
        },
        {
            key = "nbPerGroup",
            name = _("Tracks per group"),
            values = {_("1"), _("2"), _("All")},
            defaultIndex = 1
        },
        {
            key = "isMir",
            name = _("Mirrored"),
            values = {_("No"), _("Yes")},
        },
        {
            key = "slope",
            name = _("Slope(‰)"),
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "height",
            name = _("Altitude Adjustment(m)"),
            values = func.map(heightList, tostring),
        }
    }

end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Concrete Flying Junction"),
            description = _("An European style flying junction")
        },
        availability = {
            yearFrom = 1892
        },
        -- buildMode = "MULTI",
        -- categories = {"tracks"},
        order = 27218,
        -- skipCollision = false,
        -- autoRemovable = false,
        params = params(),
        
        updateFn = function(params)
            defaultParams(params)
            
            local result = {}
            
            local deg = listDegree[params.xDegDec + 1] + params.xDegUni
            local rad = math.rad(deg)
            
            local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
            local catenary = params.catenary == 1
            
            local info1 = {
                lower = {
                    nbTracks = params.nbLowerTracks + 1,
                    r = params.rLower1 == 4 and 0 or rList[params.rLower1 + 1] * -1000,
                    rad = -0.5 * rad
                },
                upper = {
                    nbTracks = params.nbUpperTracks + 1,
                    r = params.rUpper1 == 4 and 0 or rList[params.rUpper1 + 1] * 1000,
                    rad = 0.5 * rad
                }
            }
            local info2 = {
                lower = {
                    nbTracks = params.nbLowerTracks + 1,
                    r = params.rLower2 == 4 and 0 or rList[params.rLower2 + 1] * -1000,
                    rad = -0.5 * rad
                },
                upper = {
                    nbTracks = params.nbUpperTracks + 1,
                    r = params.rUpper2 == 4 and 0 or rList[params.rUpper2 + 1] * 1000,
                    rad = 0.5 * rad
                }
            }
            
            local nbPerGroup = ({1, 2, params.nbLowerTracks + 1})[params.nbPerGroup + 1]
            
            local trackBuilder = trackEdge.builder(catenary, trackType)
            local TLowerTracks = trackBuilder.normal(snapRule)
            local TUpperTracks = trackBuilder.nonAligned(snapRule)
            local TUpperTracksBridge = trackBuilder.bridge(bridgeType, station.noSnap)
            
            local offsets = {
                lower = buildCoors(info1.lower.nbTracks, nbPerGroup),
                upper = buildCoors(info1.upper.nbTracks, info1.upper.nbTracks)
            }
            
            local group1 = part(rad)(info1, offsets)
            local group2 = part(rad)(info2, offsets)
            
            local lowerTracks = generateTrackGroups(group1.lower.tracks, group2.lower.tracks)
            local upperTracks = generateTrackGroups(group1.upper.tracks, group2.upper.tracks, {mpt = coor.transZ(11), mvec = coor.I()})
            
            result.edgeLists =
                {
                    TUpperTracks(upperTracks),
                    TLowerTracks(lowerTracks),
                }
            
            dump.dump(result.edgeLists)
            
            result.models = {}
            
            result.terrainAlignmentLists = {{
                type = "EQUAL",
                faces = {
                }
            },
            }
            
            -- End of generation
            -- Slope, Height, Mirror treatment
            local slope = slopeList[params.slope + 1]
            local ha = heightList[params.height + 1]
            local isMir = {false, true}
            local mirrored = isMir[params.isMir + 1]
            
            local mz = coor.transZ(ha)
            local mr = slopeMRotX[slope]
            local mf = mirrored and coor.flipX() or coor.I()
            
            local mpt = coor.mul(mf, mr, mz)
            local mvec = coor.mul(mf, mr)
            
            local mapEdgeList = function(edgeList)
                edgeList.edges = func.map(edgeList.edges, coor.applyEdge(mpt, mvec))
                return edgeList
            end
            
            result.edgeLists = func.map(result.edgeLists, mapEdgeList)
            
            local mapModel = function(model)
                model.transf = coor.mul(model.transf, mpt)
                return model
            end
            
            result.models = func.map(result.models, mapModel)
            
            local mapTerrainList = function(ta)
                local mapTerrain = function(t) return (coor.tuple2Vec(t) .. mpt):toTuple() end
                local mapFaces = func.bind(func.map, nil, mapTerrain)
                ta.faces = func.map(ta.faces, mapFaces)
                return ta
            end
            result.terrainAlignmentLists = func.map(result.terrainAlignmentLists, mapTerrainList)
            
            result.terminalGroups = {}
            
            result.cost = 1000
            result.maintenanceCost = 1000 / 6
            
            return result
        end
    }

end
