local func = require "jct/func"
local coor = require "jct/coor"
local pipe = require "jct/pipe"
local general = require "jct/general"
local jct = require "jct"

-- local dump = require "dump"
local wallTypes = {
    "jct/concrete_fence",
    "jct/brick_fence",
    "jct/brick_2_fence"
}

local ceilTypes = {
    "jct/concrete_ceil",
    "jct/brick_ceil",
    "jct/brick_ceil"
}

function data()
    return {
        updateFn = function(result, transform, tag, slotId, addModelFn, params, closureParams)
            local modelFence = wallTypes[params.wallType + 1]
            local modelCeil = ceilTypes[params.wallType + 1]
            
            local trackWidth = closureParams.trackWidth
            local trackType = closureParams.trackType
            local catenary = closureParams.catenary
            local isRev = closureParams.isRev or false
            local isStreet = closureParams.isStreet or false
            
            local withTag = general.withTag(tag)
            local info = jct.slotInfo(slotId)
            
            local config = info.isUpper and result.config.upper or result.config.lower
            local arcs = config.arcs[info.pos.x]
            
            local e = pipe.new
                * func.map(arcs, function(arc)
                    local isRev = isRev
                    if arc.isRev then isRev = not isRev end
                    local arc = arc.arc(0)
                    local length = isRev and -arc:length() or arc:length()
                    local pts = pipe.new
                        * {arc.inf, (arc.inf + arc.sup) * 0.5, (arc.inf + arc.sup) * 0.5, arc.sup}
                        * (isRev and pipe.rev() or pipe.noop())
                        * pipe.map(function(pt) return {arc:pt(pt), arc:tangent(pt) * length * 0.5} end)
                    
                    return pts * pipe.map(pipe.map(coor.vec2Tuple))
                end)
                * (isRev and pipe.rev() or pipe.noop())
                * pipe.flatten()
            
            local edges = {
                type = isStreet and "STREET" or "TRACK",
                edgeType = info.isUpper and "BRIDGE" or nil,
                edgeTypeName = info.isUpper and "jct_void.lua" or nil,
                alignTerrain = not info.isUpper,
                params = {
                    type = trackType,
                    catenary = catenary,
                    tramTrackType = "NO"
                },
                edges = e,
                snapNodes = {0, #e - 1},
                freeNodes = {},
                tag2nodes = {
                    [tag] = func.seq(0, #e - 1)
                },
                slot = slotId
            }
            
            table.insert(result.edgeLists, edges)
            
            local isLeftWall = config.modules[info.pos.x - 1] and config.modules[info.pos.x - 1].type == "jct_wall"
            local isRightWall = config.modules[info.pos.x + 1] and config.modules[info.pos.x + 1].type == "jct_wall"
            local leftExtend = isLeftWall and (info.pos.x - 1 == config.posMin and -0.25 or -0.5) or 0
            local rightExtend = isRightWall and (info.pos.x + 1 == config.posMax and 0.25 or 0.5) or 0
            
            local biLatCoords = func.map(arcs, function(arc)
                local biLatCoords = jct.biLatCoords(5, arc.arc)
                local isRev = arc.isRev
                local lc, rc = biLatCoords(-trackWidth * 0.5 + leftExtend, trackWidth * 0.5 + rightExtend)
                if result.config.mirrored then
                    lc, rc = rc, lc
                end
                local op = isRev and pipe.rev() or pipe.noop()
                lc, rc = op(lc), op(rc)
                return {lc = lc, rc = rc}
            end)
            
            local lc = func.mapFlatten(biLatCoords, pipe.select("lc"))
            local rc = func.mapFlatten(biLatCoords, pipe.select("rc"))
            
            table.insert(result.colliders, {
                type = "POINT_CLOUD",
                params = {
                    points = pipe.new * func.map2(jct.interlace(lc), jct.interlace(rc), function(l, r) return l.i:avg(l.s):avg(r.i:avg(r.s)) end)
                    * pipe.map(coor.vec2Tuple)
                }
            }
            )

            if (params.extType == 0 or info.isUpper) then
                result.models = result.models
                    + (function()
                        local front = {
                            {
                                {s = lc[1], i = (lc[2] - lc[1]):normalized() * 0.5 + lc[1]},
                                {s = rc[1], i = (rc[2] - rc[1]):normalized() * 0.5 + rc[1]},
                            },
                            {
                                {s = (lc[#lc - 1] - lc[#lc]):normalized() * 0.5 + lc[#lc], i = lc[#lc]},
                                {s = (rc[#rc - 1] - rc[#rc]):normalized() * 0.5 + rc[#rc], i = rc[#rc]}
                            }
                        }
                        
                        return pipe.new
                            / func.map2(
                                jct.interlace(lc), jct.interlace(rc),
                                function(baseL, baseR) return config.build.surface(nil, "jct/surface", baseL, baseR) * withTag end
                            )
                            / (info.isUpper and params.extType == 1 and func.map2(
                                jct.interlace(lc), jct.interlace(rc),
                                function(baseL, baseR) return config.build.ceil(nil, modelCeil, baseL, baseR) * withTag end
                            ) or {})
                            / (info.isUpper and {} or func.map2(
                                jct.interlace(lc), jct.interlace(rc),
                                function(baseL, baseR) return config.build.ceil(nil, modelCeil, baseL, baseR) * withTag end
                            ))
                            / func.map(front, function(base) return config.build.front(nil, modelFence, table.unpack(base)) * withTag end)
                            * pipe.flatten()
                            * pipe.flatten()
                    end)()
            end
        end,
        
        getModelsFn = function(params)
            return {}
        end
    }
end
